# はじめに

- こんなことはありませんか？
  - どこかのコードを変更すると、別の場所でバグが発生した。
  - 変更の影響がありそうな箇所を。あちこち探し回らなければならなくなった。
  - コードを読んでいるだけで日が暮れてしまった。
  - 簡単んだと思っていた仕様変更やバグ修正に何日も費やしてしまった。
  - 開発力を貶め、ソフトウェアの成長を阻害する、設計や実装状の問題、つまり「悪魔」を近くし、退治できるようにするための技術書。

# 第１章 悪しき構造の弊害を知覚する。

0. 導入
   - 設計を蔑ろにすることで発生する弊害
     - コードを読み解くのに時間がかかる
     - バグを埋め込みやすくなる
     - 悪しき構造がさらに悪しき構造を誘発する
1. 意味不明な命名
   - 技術駆動命名や連番命名は意図が全く読み取れない、悪しき手法
2. 理解を困難にする条件分岐のネスト
   - 深すぎるネストは理解困難
3. 様々な悪魔を招きやすいデータクラス
   - データの保持だけを目的としたクラスをデータクラスという
   - データクラスとそのデータを操作するクラスが別になっている場合がある
   - そのようなバラバラの状態を低凝集であるという
   - 低業集であると弊害がいろいろとある
     - 重複コード
     - 修正漏れ
     - 可読性低下
     - 未初期化状態・生焼けオブジェクト
     - 不整地の混入
4. 悪魔退治の基本
   - 悪しき構造の弊害とオブジェクト指向設計をしることで弊害を退治することができる

# 第２章 設計の初歩

0. 導入
   - 変数やメソッドなどの小さな単位の設計について扱う
1. 省略せずに意図が伝わる名前を設計する
2. 変数を使いまわさない、目的ごとの変数を用意する
   - 再代入は読み手の混乱を招くので避ける。
3. ベタ書きせず、意味のあるまとまりでメソッド化
4. 関係し合うデータとロジックをクラスにまとめる

# 第３章 クラス設計 -- 全てにつながるい設計の基盤 --

0. 導入
   - クラスベースのオブジェクト指向設計の基本について扱う
1. クラス単体で正常に動作するよう設計する
   - まどろっこしい初期設定をせずとも初めから使える設計にする
   - 正しく操作できるメソッドのみを外部に提供する
   1. 悪魔に負けない、頑強なクラスの構成要素
   - 良いクラスの構成要素
     - インスタンス変数
     - インスタンス変数を不正状態から防御し、正常に操作するメソッド
   2. すべてのクラスに備わる事故防衛責務
   - 単体で安全に利用できる自己防衛責務を全てのクラスが備えるという考えかたがソフトウェア品質を考える上で重要
2. 成熟したクラスへ成長させる設計術
   1. コンストラクタで確実に正常値を設計する
      - 初期化時以外でインスタンス変数に値を代入しないと使えないクラスは生焼けオブジェクト
      - 生焼けオブジェクトを防ぐには、「クラスのインスタンスを生成する時点で、インスタンス変数に正常値が確実に設定されている状態」にする
      - コンストラクタに不整地を渡せないように、バリデーションチェックも忘れずに
      - 処理の対象外となる条件を先頭で定義する方法をガード節という
   2. 計算ロジックをデータ保持側に寄せる
   3. 不変で思わぬ動作を防ぐ
      - 新スタンス変数の上書きは、理解を難しくする。
      - インスタンス変数を不変（イミュータブル）にする
   4. 変更したい場合は新しいインスタンスを作成する
      - インスタンス変数を変更したい場合は新しいインスタンスを生成するようにする
      - add() return new Money(addedAmount) のようなメソッドを用意しておく
   5. メソッド引数やローカル変数にも final を付け不変にする
      - void doSomething(final int amount) のように引数もイミュータブルにする
   6. 「値の渡し間違い」を型で防止する
      - 数値だからといって、考えなしに全て int 型では、チケットの枚数と間違えてチケットの金額を渡してしまうなどのミスが発生する。
      - 金額なら Money 型、枚数なら TicketCount 型などといった具合に型を使って値の渡し間違いを防ぐ
   7. 現実の営みにはないメソッドを追加しないこと
      - 金額同士の乗算のような、現実にないメソッドはバグの原因になる
3. 悪魔退治の効果を検証する

   - クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくりと言っても過言ではない
   - 密接に関係し合うロジックが一箇所にぎゅっと集まっている構造を高凝集と呼ぶ
   - データとそのデータを操作するロジックを一つのクラスにまとめ、必要なメソッドのみを外部へ公開することをカプセル化という

4. プログラム構造の問題解決に役立つ設計パターン
   - プログラム構造を改善する設計手法を設計パターン（デザインパターン）という
   - 設計パターンの例
     - 完全コンストラク: 不正状態から防護する
     - 値オブジェクト: 特定の値に関するロジックを高凝集にする
     - ストラテジ: 条件分岐を削減し、ロジックを単純化する
     - ポリシー: 条件分岐を単純化したり、カスタマイズできるようにする
     - ファーストクラスコレクション: 値オブジェクトの亜種で、コレクションに関するロジックを高凝集にする
     - スプラウトクラス: 既存のロジックを変更せずに安全に新機能を追加する
   1. 完全コンストラクタ
      - 不正状態から防護するための設計パターン
      - インスタンス変数を全て初期化するコンストラクタ
      - コンストラクタ内でガード節を使って不正状態を防ぐ
   2. 値オブジェクト
      - 値をクラスとして表現する設計パターン
      - 値にもいろいろある。それぞれのロジックを高凝集にする効果がある
      - 値オブジェクトと完全コンストラクタはオブジェクト指向設計の基本形を体現している構造の一つ

# 第４章 不変の活用 -- 安定動作を構築する --

0. 導入
   - 変更可能なことを可変（ミュータブル）、不可能なことを不変（イミュータブル）という
1. 再代入
   - 変数に再度値を代入することを再代入、または、破壊的代入という
   - 再代入はそのタイミングを追うのが難しくなる
   - 別の変数を用意するべき
   1. 不変にして再代入を防ぐ
      - final を付与する
   2. 引数も不変にする
      - 引数にも void doSomething(final int amount) のように fainal を付与する
2. 可変がもたらす意図せぬ影響
   1. 可変インスタンスの使い回し
      - 意図せずに変更してしまうことがある
   2. 関数による可変インスタンスの操作
   3. 副作用のデメリット
      - 関数の主作用: 関数が引数を受け取り、値を返すこと
      - 関数の副作用: 主作用以外に状態変更すること
      - 副作用の例
        - インスタンス変数の変更
        - グローバル変数の変更
        - 引数の変更
        - ファイルの読み書きなどの I/O 操作
      - 副作用が予期せぬタイミングで働いてしまう場合がある
   4. 関数の影響範囲を限定する
      - 副作用を抑えるため、関数が影響を受ける・与える範囲を限定するのが確実
      - 関数を次のように設計する
        - データ、つまり状態を引数で受け取る
        - 状態を変更しない
        - 値は関数の戻り値として返す
      - オブジェクト指向では、副作用のない関数を厳密に作り込むのではなく、クラスのスコープ内で影響を閉じ込めるスタイルが一般的
   5. 不変にして予期せぬ動作を防ぐ
3. 可変と不変の取り扱い方針
   - 可変と不変をどのように扱っていけばいいのか？
   1. デフォルトは不変に
      - 不変にすることによるメリット
        - 変数の意味が変化しなくなるので、混乱が抑えられる
        - 挙動が安定し、結果を予測しやすくなる
        - コードの影響範囲が限定的になり、保守が用意になる
      - 間違った使い方ができない構造をフールプルーフという
   2. どんなとき可変にしてよいか
      - インスタンスを生む処理がパフォーマンスの面で問題なら可変もありえる
      - スコープが局所的な場合も可変がありえる
   3. 正しく状態変更するメソッドを設計する
      - 可変にする場合は、正しく状態変更できるつくりにする
      - 状態変更メソッドをミューテーターという
   4. コード外とのやりとりは局所化する
      - どれだけ不変を意識しても、I/O 操作や DB 操作など、コード外の状態に依存する場合はある
      - なので、あまり考えずに外の状態に依存するコードを書くと、挙動の予測が困難になる
      - 影響を最小限にするための局所化の設計手法としてリポジトリパターンが人気
      - リポジトリパターン: データベースの永続化処理をカプセル化する設計パターン

# 第 5 章 低凝集 -- バラバラになったモノたち --

0.  導入
    - 高凝集は変更に強い、望ましい設計
    - 低凝集は壊れやすく変更が困難
1.  static メソッドの誤用
    1. static メソッドはインスタンス変数を使えない
       - static メソッドはインスタンス変数を扱えない時点でデータとデータを扱うロジックが乖離する
    2. インスタンス変数を使う構造につくり変える
    3. インスタンスメソッドのフリした static メソッドに注意
       - static キーワードがついていないだけで、static メソッドと同じ問題をかけているインスタンスメソッドもよくある
       - 試しに、メソッドに static を付与して、エラーが派生しなければそれは実質 static メソッドだ
    4. どうして static メソッドが使われてしまうのか
       - 手続き型言語の名残り
    5. どういうとき static メソッドを使えばいいのか
       - ファクトリメソッドとして static メソッドを用いるのがよい
2.  初期化ロジックの分散
    - 本当にコンストラクタを公開してよいのか吟味する
    - コンストラクタを公開すると、様々な用途であちこちで使われてしまう
    - 用途を限定したいならば、コンストラクタを private にして、static な目的別のファクトリメソッドを用意する
    1. private コンストラクタ + ファクトリメソッドで目的別初期化
    2. 生成ロジックが増えすぎたらファクトリクラスを検討すること
       - 複数の生成パターンがあり、使い分けが必要（通常ユーザー、プレミアムユーザーなど）
3.  共通処理クラス（Common・Util）

    - 同じような処理が多数描かれそうなとき、再利用できるよう共通処理を実装した共通クラスがつくられることがある。
    - このとき、共通処理用のメソッドは static メソッドとして実装されがち
    - Common.calcAmoutIncludingTax(amount) のようなもの
    - これもまた低凝集である

    1. さまざまなロジックが雑多に置かれがち
       - なんの関連性もないその他のロジックの置き場になってしまう場合がある
    2. オブジェクト指向設計の基本に立ち返ろう
       - 共通処理クラスを安易に作らないようにしよう
    3. 横断的関心事
       - 横断的関心事は共通処理クラスにまとめ上げていい
       - 横断的関心事: 様々なユースケースに広く横断する事柄
         - ログ出力
         - エラー検出
         - デバッグ
         - 例外処理
         - キャッシュ
         - 同期処理
         - 分散処理
    4. 結果を返すために引数を使わないこと
       - 引数はあくまで入力値
       - メソッドの中で引数として受け取ったものを再代入したり、出力に用いたりしない
       - 低凝集の原因になる
    5. 多すぎる引数

       - 引数が多すぎると低凝集になりがち
       - 引数が多すぎると、引数の渡しミスが発生しやすい

       1. プリミティブ型執着

          - プリミティブ型を濫用したコードをプリミティブ型執着という
          - 例えば、プリミティブ型を使用すると同様のバリデーションが重複してしまう price < 0 など
          - 値とそれを操作するためのメソッドが存在する以上、セットにしておくのが適切
          - 割引料金、定価、割引率なども、それぞれ一つずつクラス化する

       2. 意味のある単位ごとにクラス化する

          - 引数が多すぎる事態に陥らないためには、概念的に意味のあるクラスをつくることが肝要
          - 引数が多い場合は、データを引数として扱うのではなく、その値をインスタンス変数としてもつクラスにできないか検討するとよい

    6. メソッドチェイン

       - 長すぎるメソッドチェインに値を代入するようなケースも低凝集に陥りやすい例
       - party.members[memberId].equipments.armor = newArmor; のようなコード
       - デメテルの法則: 「最小知識の原則」とも呼ばれる、「オブジェクトは、直接の友人とだけ会話すべき」という考え方

       1. 尋ねるな、命じろ

       - Don't ask, tell(訪ねるな、命じろ): オブジェクトの内部状態を外から取得して判断するのではなく、オブジェクトに直接処理を命じるべき

       - 悪い例（外部で計算）

       ```typescript
       // 外部で計算（尋ねて判断）
       const product = new Product(1000, 0.2);
       const price = product.getPrice();
       const rate = product.getDiscountRate();
       const finalPrice = price * (1 - rate); // 外部で計算ロジックを実装
       ```

       - 良い例（オブジェクトに命じる）

       ```typescript
       // 商品に計算を命じるだけ
       const product = new Product(1000, 0.2);
       const finalPrice = product.calculateDiscountedPrice();
       ```

# 第 6 章 条件分岐 -- 迷宮かした分岐処理を解きほぐす技法 --

1. 条件分岐のネストによる可読性低下
   1. 早期 return でネスト解消
      - 早期 return: 条件を満たしていない場合に、直ちに return すること
      - 早期 return に変更するには、元の条件を反転させる
      - 早期 return はガード節の考え方が元になっている
   2. 見通しを悪くする else 句も早期 return で解決
      - else 句も、見通しを悪くする要因の一つ
2. switch 文の重複

   1. 即座に switch 文を書いてしまう
   2. 同じ条件式の switch 文が複数かかれていく
   3. 使用変更時の修正漏れ(case 文追加漏れ)
   4. 爆発的に増殖する switch 文の重複

      - 大量に分岐していくものを switch 文で処理しようとするとミスが発生する

   5. 条件分岐を一箇所にまとめる
      - switch 文の重複コードを解消するには、単一責任の原則の考え方が重要
   6. よりスマートに switch 文重複を解消する interface
      - interface は異なる型を同じ型として利用できるようにするもの
   7. interfafce を switch 重複文に応用（ストラテジパターン）
      - interface Shape に area()メソッドを定義して、Circle や Rectangle でもこれを継承することにより、それぞれの area()メソッドを定義することができる
      - Map<final MagicType, final Magic> の中から、MagicType に対応する Magic を取得することで魔法を切り替える手法もいい考え
      - ストラテジパターン: interface を用いて処理を一成に切り替える設計
      - interface を implements した場合、変数やメソッドのオーバーライドを忘れることがなくなる

3. 条件分岐の重複とネスト

   - 条件分岐の重複とネストは、コードの可読性を低下させる

   1. interface は多重ネストの解消にも役立つ
   2. ポリシーパターンで条件を集約する
      - ポリシーパターン: 「同じような処理だけど、状況によって少しずつ異なる振る舞いが必要な場合に、その振る舞いを別々のクラスとして実装し、実行時に切り替えられるようにするデザインパターン」
      - 例えば：
        - 会員ランクによって異なる割引率の計算
        - ユーザーの状態によって異なる通知方法
        - 支払い方法による異なる決済処理
      - など、「同じような処理だけど、条件によって少し違う」というケースで使用します。

4. 型チェックで分岐しないこと
   - わざわざス interface を実装しているのに、if (hotelRates instanceof RegularRates) のように型チェックによる条件分岐をするのは悪手
   - ストラテジパターンでは、型チェックせずに、共通項を利用できるのがメリット。それを損なっている
   - リスコフの置換原則にも反している
   - リスコフの置換原則: 親クラスが使われている場所では、そのサブクラス（子クラス）で置き換えても、プログラムが正しく動作すべき」という原則
5. interface の使いこなしが中級者への第一歩
   - interface を使いこなせるかが、設計スキルの分水嶺といっても過言ではない
   - 分岐を書きそうになったら、まず interface 設計！
6. フラグ引数
   - メソッドの機能を切り替えるための boolean 値をフラグ引数という
   - フラグ引数は可読性を低下させる
   - boolean 型以外、int 型等であっても、同様のものは可読性を損なう
   1. メソッドを分離する
      - フラグ引数付きメソッドは、内部に複数の機能を持ち、フラグで切り替える構造になっている
      - 単機能になるように、メソッドを分離するとよい
      - 分離したメソッドに相応しい命名をすることで可読性が向上する
   2. 切り替え機構をストラテジパターンで実現する
      - 分離したメソッドを boolean 型で条件分岐して使用してしまっては意味がない
      - ストラテジパターンで切り替える

# 第 7 章 コレクション -- ネストを解消する構造化技法 --

1. わざわざ自前でコレクション処理を実装してしまう
   - List などのコレクション処理には、便利なメソッドが行順ライブラリとして収録されている
   - for や if を使いそうになったら、まずは標準ライブラリから探してみるといい
2. ループ処理中の条件分岐ネスト

   - for 文の中に if 文が何重にもネストされているようなものを改善したい

   1. 早期 continue で条件分岐のネストを解消する

      - 早期 continue: 条件を満たしていない場合に、直ちに continue すること
      - 早期 continue によりネスト解消される

   2. 早期 break もネスト解消に役立つ
      - 早期 break: 条件を満たしている場合に、直ちに break すること

3. 低凝集なコレクション処理
   - コレクション処理も低凝集に陥りやすい
   - コレクションを操作する処理は、アプリケーションの複数の部分で必要とされるため、ついつい個別に実装されてしまい、コードが分散してしまう傾向がある
   1. コレクション処理をカプセル化する
      - ファーストクラスコレクション: コレクションに関するロジックをカプセル化する設計パターン
      - ファーストクラスコレクションは以下の要素を備える
        - コレクション型インスタンス
        - コレクション型インスタンス変数を不正状態から防御し、正常に操作するメソッド
   2. 外部へ渡す場合はコレクションを変更できなくする
      - ファーストクラスコレクションからメソッドを通じてインスタンス変数を外部に渡す際には、return members.unmodifiableList\*(); としてイミュータブルなものを渡す

# 第 8 章 密結合 -- 絡まって解きほぐせない構造 --

0. 導入
   - 結合度: モジュール間の、依存の度合いを表す指標
   - 密結合: あるクラスが、他の多くのクラスに依存している構造
1. 密結合と責務
   1. 発生する様々なバグ
   2. ロジックの起き場所がちぐはぐ
      - 責務が考慮されていないクラス設計
        - 特定のクラスが責務以上の処理を引き受けてしまっている
        - 他のクラスが行うべきバリデーションを引き受けてしまっている
        - 同じ名称のメソッドが複数のクラスに存在する
        - 継承関係のクラスにおいて、オーバーライドにより、本来するべきでないロジックの流用を行なっている。
   3. 単一責任の原則
      - ソフトウェアにおける責任: ある関心事について、不正な動作にならないよう正常に動作するよう制御する責任
      - 単一責任の原則: クラスが担う責任は、たったひとつに限定すべきとする設計原則
   4. 単一責任の原則違反で生まれる悪魔
      - 単一責任の原則の未履行が過保護なクラスと未熟なクラスを生み、さらに重複コードを生む。
   5. 責任が単一になるようクラスを設計する
      - 例: 商品の定価クラスを親とし、それを通常割引価格とかき割引価格がそれぞれ別に継承する。
      - 関心事それぞれが分離、独立している構造を疎結合という
   6. DRY の原則の誤用
      - DRY の原則: 全ての知識はシステム内において、単一、かつ明確な、そして信頼できる表現になっていなければならない。
      - 同じようなロジック、にているロジックであっても、概念が違えば DRY にすべきではない。
      - DRY にしすぎると密結合になり、単一責任原則を遵守できなくなる。
2. 密結合の各種事例と対処方法
   1. 継承に絡む密結合
      - 本書のスタンス: 継承はよっぽど注意して扱わないと危険、継承は推奨しない。
      - スーパークラス依存: サブクラスはスーパークラスの変更の影響をもろに受けるので、常に気にしなければならない。
      - 継承より委譲
        - 委譲とは、コンポジション構造にすること
        - 委譲: スーパークラスを継承するのではなく、private なインスタンス変数として持ち、呼び出せるようにすること
      - 関連知識が基底クラスと継承クラスに分散してしまう
   2. インスタンス変数ごとにクラス分割可能なロジック
      - インスタンス変数とそれを用いたメソッドのセットが他のセットと依存関係にないのなら、クラスを分離するべき
      - 影響スケッチ: インスタンス変数やメソッドがそれぞれ何に関係付けられているのか把握するための図
      - 影響スケッチ描画ツール: Jig
   3. なんでも public で密結合
      - public: すべてのクラスからアクセス可能
      - protected: 同じクラス、または継承クラスからアクセス可能
      - なし: 同じパッケージからのみアクセス可能
      - private: 同じクラスからのみアクセス可能
   4. privare メソッドだらけ
   5. 高凝集の誤解からくる密結合
      - 高凝集を意図して強く関係していそうなロジックを一箇所にまとめあげようとしたものの、結果として見つけつ行に陥っているケースは非常に多く見られる。誰もが極めて陥りやすい罠。
      - 疎結合高凝集を意識しなければならない。
      - 疎結合高凝集: モジュール（クラス）の中は密接に関連した機能をまとめ（高凝集）、モジュール間の依存関係は最小限に抑える（疎結合）設計原則
   6. スマート UI
      - スマート UI: 表示関連のクラスの中に、表示遺体の責務のロジックが実装されている構造
      - スマート UI は表示責務と表示以外の計算等の責務が密結合になっているせいで、変更が難しくなる。
      - 責務毎にグラスを分割すべき。
   7. 巨大データクラス
      - 巨大データクラス: 大量のインスタンス変数を保持するクラス
      - 巨大データクラスの持つデータがグローバル変数の性質を帯びてしまうことがあるので注意。
   8. トランザクションスクリプトパターン
      - トランザクションスクリプトパターン: メソッド内に一連の処理手順がダラダラと長く書き連ねられている構造
   9. 神クラス
      - 神クラス: 1 クラス内に何千何万行ものロジックを持ち、あらゆる責務のロジックが乱雑に絡み合うようにかき殴られているようなクラス
      - 大変扱いにくいものになってしまう
   10. 密結合クラスの対処法
   - 巨大データクラスもトランザクションスクリプトパターンも神クラスも、密結合なクラスの対処方法はどれも同じ。
   - オブジェクト指向設計と単一責任の原則に基づき、丁寧に設計すること。

# 第 9 章 設計の健全性をそこなうさまざまな悪魔たち

1. デッドコード
   - デッドコード: どんな条件であっても決して実行されないコード
   - 到達不能コードともいう
   - 発見次第すぐに削除する
2. YAGUNI 原則
   - You aren't going to need it. -- 必要ないでしょう。
   - YAGUNI 原則: 実際に必要になっとときに実装せよ。先回りして必要のないロジックを実装しない。
3. マジックナンバー
   - マジックナンバー: ロジックないに直接書き込まれている意味不明な数値
   - マジックナンバーにならないよう、定数として定義する。
4. 文字列型執着
   - 文字列型執着: String title = "タイトル, 255, 250, 240, 64"のようなもの
   - 扱い方が複雑になるので避ける
5. グローバル変数
   - グローバル変数: どこからでもアクセス可能な変数。public static などで宣言される。
   1. 影響範囲を最小化するよう設計すること
      - 呼び出し箇所が少なく、局所化されているほど、ロジックの理解が容易になる。
      - 無関係なロジックからはアクセスできないように設計する
6. null 問題
   - null を使いがちだが、
   - 本来 null とは、「参照が何も指していない状態」または「参照の欠如」を表す特別な値であり、「空」や「未設定」とは異なる概念。
   1. null を返さない、渡さない
      - null チェックだらけにならないようにするためにも、そもそも null を取り扱わない設計にすることが大切
   2. null 安全
      - null 安全: null が原因のエラーを発生させない仕組み
      - null 非許容型: null を許容しない型
7. 例外の握りつぶし
   - 例外の握りつぶし: 例外が発生しても何も対処せず、エラーを無視してしまうこと。特に空の catch ブロックを作ることで、エラーの発生を隠蔽してしまう行為
   1. 原因分析困難に陥り開発者を疲弊させる
   2. 問題検出時にけたたましく叫ばせる
8. 設計秩序を破壊するメタプログラミング
   - メタプログラミング: プログラム実行時にそのプログラム構造自体を制御するプログラミング
   1. リフレクションによるクラス構造および値の変更
      - リフレクションを使うと final で不変にした変数を可変にすることができてしまう
   2. 型の強みを活かせなくなるハードコード
      - リフレクションを使うと、クラス名を Stringto として渡すことでクラスを生成することができる。
      - しかし、クラス名を変更してしまえば、その処理は機能しなくなる。
      - 名前によるクラスの生成は、IDE がクラスの生成として見つけることもできない。
   3. デメリットを理解しようとを限定すること
      - メタプログラミングは黒魔術
9. 技術駆動パッケージング
   - 技術駆動パッケージング: 設計パターンなど、構造的ににているもの同志でフォルダ分け、パッケージ分けなどをすること
   - ビジネス概念として強く関係試合もの同志が一緒になるようにフォルダ分けをしなければならない
10. サンプルコードのコピペ

- サンプルコードには保守性や変更用意性まで考えて書かれていない

11. 銀の弾丸

- 現実のプロジェクトで発生する問題は特定の手法だけで解決可能なほど単純でない
- 銀の弾丸や特攻薬のようなものは求めないようにする

# 第 10 章 名前設計 -- あるべき構造を見破る名前 --

0. 導入

- 目的駆動名前設計: コードの名前（クラス名、メソッド名、変数名）を、その目的や意図が明確に伝わるように設計すること

1. 悪魔を呼び寄せる名前
   1. 関心の分離
      - 関心の分離: 関心事それぞれのクラスへの分割が必要
   2. 関心事にふさわしい命名
      - 商品ではなく、予約品、注文品、在庫品、発送品 など、関心事にふさわしい命名をする
      - クラス毎の影響範囲が低減し、開発効率が上がる
   3. 大雑把で意味が不明瞭な名前
      - 開発初期に決めた名前は大雑把であることがおおい
      - 目的不明オブジェクト: 名前が大雑把で目的がわからないオブジェクト。
2. 名前を設計する -- 目的駆動名前設計
   - プログラミングにおける名前の役割は、可読性を高めることだけではない
   - 目的駆動名前設計のポイント
     - 可能な限り具体的で、意味範囲が狭い、特化した名前を選ぶ
     - 存在ベースではなく、目的ベースで名前を考える
     - どんな関心事があるか分析する
     - 声に出して話してみる
     - 利用規約を読んでみる
     - 違う名前に置き換えられないか検討する
     - 疎結合高凝集になっているか点検する
   1. 可能な限り具体的で、意味範囲が狭い、目的に特化した名前を選ぶ
      　 - 極めて意味範囲の狭い名前をクラスに付与し、ビジネス目的に特化することで得られる効果 - 名前とは無関係なロジックを排除しやすくなる - クラスが小さくなる - 関係するクラスの個数が小さくなる。結合度が低減する。 - 関係クラスの個数が少ないので、使用変更時に考慮を要する影響範囲が小さく済む。 - 目的に特化した名前なので、どこを変更すれば良いかすぐ探し出せる。 - 開発生産性が向上する。
   2. 存在ベースではなく、目的ベースで名前を考える。
      - 目的ベースで考えた命名の例
        - 住所: 発送元、発送先、勤務先、本籍地
        - ユーザー名: アカウント名、表示名、本名、法人名
   3. どんなビジネス目的があるのか分析する
   4. 声に出して話してみる
      - ラバーダッキング: 問題に直面したとき、そのことを誰かに話すことによって自ら原因に気づき、自己解決する手法
   5. 利用規約を読んでみる
      - サービスの利用規約には厳密な言葉が使われている。
      - 利用規約からクラス名のヒントが得られることがある。
   6. 違う名前に置き換えられないか検討する
      - 「顧客」でも広い。「宿泊客」と「支払い者」に分けるなど。
   7. 疎結合高凝集になっているか点検する
      - 低凝集や密結合になっているなら、もっと狭い意味の、特化した名前を探してみる。
3. 設計時の注意すべきリスク
   1. 名前無頓着になるな
      - チーム開発においては、命名が重要であり、名前とロジックが対応する前提であること、名前がプログラム構造を大きく左右することをチームで約束すること
   2. 使用変更時の「意味範囲の変化」に警戒
      - 名前と中身は連動している。
      - 一方の仕様が変わるなら、もう一方についても検討するべき
   3. 会話には登場するのにコード上に登場しない名前に注意
      - 会話に登場する重要な概念が、ソースコード上で名前も付けられず、雑多なロジックの中に埋没していることが本当に頻繁に見受けらる。
      - その概念をソースコード上から見つけるのが大変になってしまう
   4. 形容詞で区別が必要なときはクラス化のチャンス
      - 違いの見分けが難しいコードを、口頭でひたすら形容詞をつけて同僚に説明する状況がある。
      - 「元々の〜」「補正された〜」などの形容詞を用いて、説明する必要があるのなら、それはクラス化する必要がある
      - 要注意感イン、新品価格、中古価格、シニア料金用、平日のシニア料金用 など
4. 意図がわからない名前
   - 命名で陥りがちなさまざまな悪しきケース
   1. 技術駆動命名
      - 技術駆動命名: プログラミング用語やコンピューター用語由来の命名
      - MemotyStateManager, changeIntValue01 など
   2. ロジック構造をなぞった名前
      - isMemberHpMoreThanZeroAndIsMenberCanAct のようなもの
      - 意図、目的がわかるよう命名しよう
   3. 驚き最小の原則
      - 驚き最小の原則: 使う側が想像した通りに利用できるよう、ロジックと名前を対応付ける設計が大事
5. 構造を大きく歪ませてしまう名前
6. データクラスに陥る名前
   - ~Data, ~Ingo のような命名はデータクラスを生んでしまう。避けよう。
   - Data Transfer Object (DTO) : 「データを運ぶだけの単純なオブジェクト」は認められる。
7. クラスが巨大化する名前
   - ~Manager, ~Service, ~Controller のような命名は、クラスが巨大化する原因になる。
   - より厳密な命名をする
8. 状況によって意味や扱いが異なる名前
   - アカウント: 金融業界では「銀行口座」、コンピューターセキュリティでは「ログイン権限」
   - 状況により意味合いが異なる
   - コンテキスト（状況）が違う場合についてはクラスを分けよう。
   - Car でも配送局面と販売局面でコンテキストが全く違うのでクラスを分ける。
9. 連番命名
   - 連番命名: クラスやメソッドに番号をつけて命名すること
   - 連番命名はトランザクションスクリプトパターンに容易に陥らせてしまう
   - トランザクションスクリプトパターン: メソッド内に一連の処理手順がダラダラと長く書き連ねられている構造
10. 名前的に居場所が不自然なメソッド
    1. 「動詞 + 目的後」のメソッド名に注意
       - addItemToParty のような「動詞 + 目的後」の命名は不適切なクラスへの実装だからこそ起こりやすい。
    2. 可能な限り同志１語で済む名前にする
       - 「動詞 + 目的後」のメソッドは、目的後の概念を表現するクラスをつくり、そこに動詞１語のメソッドとして実装する。
       - addItemToParty のようなメソッドは、PartyItenms クラスに add()として実装する。
    3. 不適切な居場所の boolean メソッド
       - boolean 型を返すメソッドは責務外のクラスに実装されがち
       - クラス名 is 状態. にして適切な文章になれば OK
       - Member is in confusion. → 　 Menber クラスに isConfusion()メソッドを実装する
11. 名前の省略
    - 名前の省略には注意が必要
    1. 意図がわからなくなる省略
       - 長い名前が嫌なため、省略した名前が書かれてしまう → 意図がわからなくなる
    2. 基本的に名前は省略しないこと
       - エディタの保管機能があるから大丈夫。省略せずに書こう。
    3. そのほか省略をどう判断するか
       - 可能な限り省略せ雨ｚに意図を伝える命名が望ましい

# 第 11 章 コメント -- 保守と変更の正確性を高める書き方 --

0. 導入
   - 理解を促し、保守や変更の正確性を高めるコメントとは
1. 退化コメント
   - 退化コメント: 情報が古くなり実装を正しく説明しなくなったコメント
   1. コメントは書き手の意思の劣化コピーにすぎないことを理解すること
   2. ロジックの挙動をなぞるだけのコメントは退化しやすい
      - ロジックの挙動をなぞるだけのコメントは理解にさほど貢献しない上に、逆に偽情報が紛れ込んで害をなす可能性があり、役立たない。
2. コメントで命名をごまかす
   - ダメなメソッドに対してコメントで補足説明が必要になったときには、メソッド名のブラッシュアップを考えよう。
3. 意図や仕様変更時の注意点を読み手に伝えること
   - コードは保守と使用変更時に読まれる
   - コード保守の際、読み手が気にすること「このロジックはどういう意図で動いているのか」
   - 仕様変国の際、読み手が気にすること「何に注意すれば安全に変更できるか」
4. コメントのルール まとめ
   - コメントのルールまとめ
     | ルール | 理由 |
     |--------|------|
     | ロジック変更時、同時に必ずコメントも変更すること。 | コメントを変更しないと、ロジックと乖離した「退化コメント」が生じ、読み手が混乱するため。 |
     | ロジックの内容をなぞるだけのコメントをしないこと。 | あまり可読性に貢献しない上、コメントのメンテナンスが大変になるため。退化コメントも発生しやすい。 |
     | 可読性の悪いロジックを補足説明するようなコメントをしないこと。代わりにロジックの可読性を高めること。 | コメントのメンテナンスが大変になるため。退化コメントも発生しやすい。 |
     | ロジックの意図や仕様変更時の注意点をコメントすること。 | 保守や仕様変更時の助けになる。 |
5. ドキュメントコメント
   - 積極的に使おう！コードの保守に特に役立つ。

# はじめに

- こんなことはありませんか？
  - どこかのコードを変更すると、別の場所でバグが発生した。
  - 変更の影響がありそうな箇所を。あちこち探し回らなければならなくなった。
  - コードを読んでいるだけで日が暮れてしまった。
  - 簡単んだと思っていた仕様変更やバグ修正に何日も費やしてしまった。
  - 開発力を貶め、ソフトウェアの成長を阻害する、設計や実装状の問題、つまり「悪魔」を近くし、退治できるようにするための技術書。

# 第１章 悪しき構造の弊害を知覚する。

0. 導入
   - 設計を蔑ろにすることで発生する弊害
     - コードを読み解くのに時間がかかる
     - バグを埋め込みやすくなる
     - 悪しき構造がさらに悪しき構造を誘発する
1. 意味不明な命名
   - 技術駆動命名や連番命名は意図が全く読み取れない、悪しき手法
2. 理解を困難にする条件分岐のネスト
   - 深すぎるネストは理解困難
3. 様々な悪魔を招きやすいデータクラス
   - データの保持だけを目的としたクラスをデータクラスという
   - データクラスとそのデータを操作するクラスが別になっている場合がある
   - そのようなバラバラの状態を低凝集であるという
   - 低業集であると弊害がいろいろとある
     - 重複コード
     - 修正漏れ
     - 可読性低下
     - 未初期化状態・生焼けオブジェクト
     - 不整地の混入
4. 悪魔退治の基本
   - 悪しき構造の弊害とオブジェクト指向設計をしることで弊害を退治することができる

# 第２章 設計の初歩

0. 導入
   - 変数やメソッドなどの小さな単位の設計について扱う
1. 省略せずに意図が伝わる名前を設計する
2. 変数を使いまわさない、目的ごとの変数を用意する
   - 再代入は読み手の混乱を招くので避ける。
3. ベタ書きせず、意味のあるまとまりでメソッド化
4. 関係し合うデータとロジックをクラスにまとめる

# 第３章 クラス設計 -- 全てにつながるい設計の基盤 --

0. 導入
   - クラスベースのオブジェクト指向設計の基本について扱う
1. クラス単体で正常に動作するよう設計する
   - まどろっこしい初期設定をせずとも初めから使える設計にする
   - 正しく操作できるメソッドのみを外部に提供する
   1. 悪魔に負けない、頑強なクラスの構成要素
   - 良いクラスの構成要素
     - インスタンス変数
     - インスタンス変数を不正状態から防御し、正常に操作するメソッド
   2. すべてのクラスに備わる事故防衛責務
   - 単体で安全に利用できる自己防衛責務を全てのクラスが備えるという考えかたがソフトウェア品質を考える上で重要
2. 成熟したクラスへ成長させる設計術
   1. コンストラクタで確実に正常値を設計する
      - 初期化時以外でインスタンス変数に値を代入しないと使えないクラスは生焼けオブジェクト
      - 生焼けオブジェクトを防ぐには、「クラスのインスタンスを生成する時点で、インスタンス変数に正常値が確実に設定されている状態」にする
      - コンストラクタに不整地を渡せないように、バリデーションチェックも忘れずに
      - 処理の対象外となる条件を先頭で定義する方法をガード節という
   2. 計算ロジックをデータ保持側に寄せる
   3. 不変で思わぬ動作を防ぐ
      - 新スタンス変数の上書きは、理解を難しくする。
      - インスタンス変数を不変（イミュータブル）にする
   4. 変更したい場合は新しいインスタンスを作成する
      - インスタンス変数を変更したい場合は新しいインスタンスを生成するようにする
      - add() return new Money(addedAmount) のようなメソッドを用意しておく
   5. メソッド引数やローカル変数にも final を付け不変にする
      - void doSomething(final int amount) のように引数もイミュータブルにする
   6. 「値の渡し間違い」を型で防止する
      - 数値だからといって、考えなしに全て int 型では、チケットの枚数と間違えてチケットの金額を渡してしまうなどのミスが発生する。
      - 金額なら Money 型、枚数なら TicketCount 型などといった具合に型を使って値の渡し間違いを防ぐ
   7. 現実の営みにはないメソッドを追加しないこと
      - 金額同士の乗算のような、現実にないメソッドはバグの原因になる
3. 悪魔退治の効果を検証する

   - クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくりと言っても過言ではない
   - 密接に関係し合うロジックが一箇所にぎゅっと集まっている構造を高凝集と呼ぶ
   - データとそのデータを操作するロジックを一つのクラスにまとめ、必要なメソッドのみを外部へ公開することをカプセル化という

4. プログラム構造の問題解決に役立つ設計パターン
   - プログラム構造を改善する設計手法を設計パターン（デザインパターン）という
   - 設計パターンの例
     - 完全コンストラク: 不正状態から防護する
     - 値オブジェクト: 特定の値に関するロジックを高凝集にする
     - ストラテジ: 条件分岐を削減し、ロジックを単純化する
     - ポリシー: 条件分岐を単純化したり、カスタマイズできるようにする
     - ファーストクラスコレクション: 値オブジェクトの亜種で、コレクションに関するロジックを高凝集にする
     - スプラウトクラス: 既存のロジックを変更せずに安全に新機能を追加する
   1. 完全コンストラクタ
      - 不正状態から防護するための設計パターン
      - インスタンス変数を全て初期化するコンストラクタ
      - コンストラクタ内でガード節を使って不正状態を防ぐ
   2. 値オブジェクト
      - 値をクラスとして表現する設計パターン
      - 値にもいろいろある。それぞれのロジックを高凝集にする効果がある
      - 値オブジェクトと完全コンストラクタはオブジェクト指向設計の基本形を体現している構造の一つ

# 第４章 不変の活用 -- 安定動作を構築する --

0. 導入
   - 変更可能なことを可変（ミュータブル）、不可能なことを不変（イミュータブル）という
1. 再代入
   - 変数に再度値を代入することを再代入、または、破壊的代入という
   - 再代入はそのタイミングを追うのが難しくなる
   - 別の変数を用意するべき
   1. 不変にして再代入を防ぐ
      - final を付与する
   2. 引数も不変にする
      - 引数にも void doSomething(final int amount) のように fainal を付与する
2. 可変がもたらす意図せぬ影響
   1. 可変インスタンスの使い回し
      - 意図せずに変更してしまうことがある
   2. 関数による可変インスタンスの操作
   3. 副作用のデメリット
      - 関数の主作用: 関数が引数を受け取り、値を返すこと
      - 関数の副作用: 主作用以外に状態変更すること
      - 副作用の例
        - インスタンス変数の変更
        - グローバル変数の変更
        - 引数の変更
        - ファイルの読み書きなどの I/O 操作
      - 副作用が予期せぬタイミングで働いてしまう場合がある
   4. 関数の影響範囲を限定する
      - 副作用を抑えるため、関数が影響を受ける・与える範囲を限定するのが確実
      - 関数を次のように設計する
        - データ、つまり状態を引数で受け取る
        - 状態を変更しない
        - 値は関数の戻り値として返す
      - オブジェクト指向では、副作用のない関数を厳密に作り込むのではなく、クラスのスコープ内で影響を閉じ込めるスタイルが一般的
   5. 不変にして予期せぬ動作を防ぐ
3. 可変と不変の取り扱い方針
   - 可変と不変をどのように扱っていけばいいのか？
   1. デフォルトは不変に
      - 不変にすることによるメリット
        - 変数の意味が変化しなくなるので、混乱が抑えられる
        - 挙動が安定し、結果を予測しやすくなる
        - コードの影響範囲が限定的になり、保守が用意になる
      - 間違った使い方ができない構造をフールプルーフという
   2. どんなとき可変にしてよいか
      - インスタンスを生む処理がパフォーマンスの面で問題なら可変もありえる
      - スコープが局所的な場合も可変がありえる
   3. 正しく状態変更するメソッドを設計する
      - 可変にする場合は、正しく状態変更できるつくりにする
      - 状態変更メソッドをミューテーターという
   4. コード外とのやりとりは局所化する
      - どれだけ不変を意識しても、I/O 操作や DB 操作など、コード外の状態に依存する場合はある
      - なので、あまり考えずに外の状態に依存するコードを書くと、挙動の予測が困難になる
      - 影響を最小限にするための局所化の設計手法としてリポジトリパターンが人気
      - リポジトリパターン: データベースの永続化処理をカプセル化する設計パターン

# 第 5 章 低凝集 -- バラバラになったモノたち --

0.  導入
    - 高凝集は変更に強い、望ましい設計
    - 低凝集は壊れやすく変更が困難
1.  static メソッドの誤用
    1. static メソッドはインスタンス変数を使えない
       - static メソッドはインスタンス変数を扱えない時点でデータとデータを扱うロジックが乖離する
    2. インスタンス変数を使う構造につくり変える
    3. インスタンスメソッドのフリした static メソッドに注意
       - static キーワードがついていないだけで、static メソッドと同じ問題をかけているインスタンスメソッドもよくある
       - 試しに、メソッドに static を付与して、エラーが派生しなければそれは実質 static メソッドだ
    4. どうして static メソッドが使われてしまうのか
       - 手続き型言語の名残り
    5. どういうとき static メソッドを使えばいいのか
       - ファクトリメソッドとして static メソッドを用いるのがよい
2.  初期化ロジックの分散
    - 本当にコンストラクタを公開してよいのか吟味する
    - コンストラクタを公開すると、様々な用途であちこちで使われてしまう
    - 用途を限定したいならば、コンストラクタを private にして、static な目的別のファクトリメソッドを用意する
    1. private コンストラクタ + ファクトリメソッドで目的別初期化
    2. 生成ロジックが増えすぎたらファクトリクラスを検討すること
       - 複数の生成パターンがあり、使い分けが必要（通常ユーザー、プレミアムユーザーなど）
3.  共通処理クラス（Common・Util）

    - 同じような処理が多数描かれそうなとき、再利用できるよう共通処理を実装した共通クラスがつくられることがある。
    - このとき、共通処理用のメソッドは static メソッドとして実装されがち
    - Common.calcAmoutIncludingTax(amount) のようなもの
    - これもまた低凝集である

    1. さまざまなロジックが雑多に置かれがち
       - なんの関連性もないその他のロジックの置き場になってしまう場合がある
    2. オブジェクト指向設計の基本に立ち返ろう
       - 共通処理クラスを安易に作らないようにしよう
    3. 横断的関心事
       - 横断的関心事は共通処理クラスにまとめ上げていい
       - 横断的関心事: 様々なユースケースに広く横断する事柄
         - ログ出力
         - エラー検出
         - デバッグ
         - 例外処理
         - キャッシュ
         - 同期処理
         - 分散処理
    4. 結果を返すために引数を使わないこと
       - 引数はあくまで入力値
       - メソッドの中で引数として受け取ったものを再代入したり、出力に用いたりしない
       - 低凝集の原因になる
    5. 多すぎる引数

       - 引数が多すぎると低凝集になりがち
       - 引数が多すぎると、引数の渡しミスが発生しやすい

       1. プリミティブ型執着

          - プリミティブ型を濫用したコードをプリミティブ型執着という
          - 例えば、プリミティブ型を使用すると同様のバリデーションが重複してしまう price < 0 など
          - 値とそれを操作するためのメソッドが存在する以上、セットにしておくのが適切
          - 割引料金、定価、割引率なども、それぞれ一つずつクラス化する

       2. 意味のある単位ごとにクラス化する

          - 引数が多すぎる事態に陥らないためには、概念的に意味のあるクラスをつくることが肝要
          - 引数が多い場合は、データを引数として扱うのではなく、その値をインスタンス変数としてもつクラスにできないか検討するとよい

    6. メソッドチェイン

       - 長すぎるメソッドチェインに値を代入するようなケースも低凝集に陥りやすい例
       - party.members[memberId].equipments.armor = newArmor; のようなコード
       - デメテルの法則: 「最小知識の原則」とも呼ばれる、「オブジェクトは、直接の友人とだけ会話すべき」という考え方

       1. 尋ねるな、命じろ

       - Don't ask, tell(訪ねるな、命じろ): オブジェクトの内部状態を外から取得して判断するのではなく、オブジェクトに直接処理を命じるべき

       - 悪い例（外部で計算）

       ```typescript
       // 外部で計算（尋ねて判断）
       const product = new Product(1000, 0.2);
       const price = product.getPrice();
       const rate = product.getDiscountRate();
       const finalPrice = price * (1 - rate); // 外部で計算ロジックを実装
       ```

       - 良い例（オブジェクトに命じる）

       ```typescript
       // 商品に計算を命じるだけ
       const product = new Product(1000, 0.2);
       const finalPrice = product.calculateDiscountedPrice();
       ```

# 第 6 章 条件分岐 -- 迷宮かした分岐処理を解きほぐす技法 --

1. 条件分岐のネストによる可読性低下
   1. 早期 return でネスト解消
      - 早期 return: 条件を満たしていない場合に、直ちに return すること
      - 早期 return に変更するには、元の条件を反転させる
      - 早期 return はガード節の考え方が元になっている
   2. 見通しを悪くする else 句も早期 return で解決
      - else 句も、見通しを悪くする要因の一つ
2. switch 文の重複

   1. 即座に switch 文を書いてしまう
   2. 同じ条件式の switch 文が複数かかれていく
   3. 使用変更時の修正漏れ(case 文追加漏れ)
   4. 爆発的に増殖する switch 文の重複

      - 大量に分岐していくものを switch 文で処理しようとするとミスが発生する

   5. 条件分岐を一箇所にまとめる
      - switch 文の重複コードを解消するには、単一責任の原則の考え方が重要
   6. よりスマートに switch 文重複を解消する interface
      - interface は異なる型を同じ型として利用できるようにするもの
   7. interfafce を switch 重複文に応用（ストラテジパターン）
      - interface Shape に area()メソッドを定義して、Circle や Rectangle でもこれを継承することにより、それぞれの area()メソッドを定義することができる
      - Map<final MagicType, final Magic> の中から、MagicType に対応する Magic を取得することで魔法を切り替える手法もいい考え
      - ストラテジパターン: interface を用いて処理を一成に切り替える設計
      - interface を implements した場合、変数やメソッドのオーバーライドを忘れることがなくなる

3. 条件分岐の重複とネスト

   - 条件分岐の重複とネストは、コードの可読性を低下させる

   1. interface は多重ネストの解消にも役立つ
   2. ポリシーパターンで条件を集約する
      - ポリシーパターン: 「同じような処理だけど、状況によって少しずつ異なる振る舞いが必要な場合に、その振る舞いを別々のクラスとして実装し、実行時に切り替えられるようにするデザインパターン」
      - 例えば：
        - 会員ランクによって異なる割引率の計算
        - ユーザーの状態によって異なる通知方法
        - 支払い方法による異なる決済処理
      - など、「同じような処理だけど、条件によって少し違う」というケースで使用します。

4. 型チェックで分岐しないこと
   - わざわざス interface を実装しているのに、if (hotelRates instanceof RegularRates) のように型チェックによる条件分岐をするのは悪手
   - ストラテジパターンでは、型チェックせずに、共通項を利用できるのがメリット。それを損なっている
   - リスコフの置換原則にも反している
   - リスコフの置換原則: 親クラスが使われている場所では、そのサブクラス（子クラス）で置き換えても、プログラムが正しく動作すべき」という原則
5. interface の使いこなしが中級者への第一歩
   - interface を使いこなせるかが、設計スキルの分水嶺といっても過言ではない
   - 分岐を書きそうになったら、まず interface 設計！
6. フラグ引数
   - メソッドの機能を切り替えるための boolean 値をフラグ引数という
   - フラグ引数は可読性を低下させる
   - boolean 型以外、int 型等であっても、同様のものは可読性を損なう
   1. メソッドを分離する
      - フラグ引数付きメソッドは、内部に複数の機能を持ち、フラグで切り替える構造になっている
      - 単機能になるように、メソッドを分離するとよい
      - 分離したメソッドに相応しい命名をすることで可読性が向上する
   2. 切り替え機構をストラテジパターンで実現する
      - 分離したメソッドを boolean 型で条件分岐して使用してしまっては意味がない
      - ストラテジパターンで切り替える

# 第 7 章 コレクション -- ネストを解消する構造化技法 --

1. わざわざ自前でコレクション処理を実装してしまう
   - List などのコレクション処理には、便利なメソッドが行順ライブラリとして収録されている
   - for や if を使いそうになったら、まずは標準ライブラリから探してみるといい
2. ループ処理中の条件分岐ネスト

   - for 文の中に if 文が何重にもネストされているようなものを改善したい

   1. 早期 continue で条件分岐のネストを解消する

      - 早期 continue: 条件を満たしていない場合に、直ちに continue すること
      - 早期 continue によりネスト解消される

   2. 早期 break もネスト解消に役立つ
      - 早期 break: 条件を満たしている場合に、直ちに break すること

3. 低凝集なコレクション処理
   - コレクション処理も低凝集に陥りやすい
   - コレクションを操作する処理は、アプリケーションの複数の部分で必要とされるため、ついつい個別に実装されてしまい、コードが分散してしまう傾向がある
   1. コレクション処理をカプセル化する
      - ファーストクラスコレクション: コレクションに関するロジックをカプセル化する設計パターン
      - ファーストクラスコレクションは以下の要素を備える
        - コレクション型インスタンス
        - コレクション型インスタンス変数を不正状態から防御し、正常に操作するメソッド
   2. 外部へ渡す場合はコレクションを変更できなくする
      - ファーストクラスコレクションからメソッドを通じてインスタンス変数を外部に渡す際には、return members.unmodifiableList\*(); としてイミュータブルなものを渡す

# 第 8 章 密結合 -- 絡まって解きほぐせない構造 --

0. 導入
   - 結合度: モジュール間の、依存の度合いを表す指標
   - 密結合: あるクラスが、他の多くのクラスに依存している構造
1. 密結合と責務
   1. 発生する様々なバグ
   2. ロジックの起き場所がちぐはぐ
      - 責務が考慮されていないクラス設計
        - 特定のクラスが責務以上の処理を引き受けてしまっている
        - 他のクラスが行うべきバリデーションを引き受けてしまっている
        - 同じ名称のメソッドが複数のクラスに存在する
        - 継承関係のクラスにおいて、オーバーライドにより、本来するべきでないロジックの流用を行なっている。
   3. 単一責任の原則
      - ソフトウェアにおける責任: ある関心事について、不正な動作にならないよう正常に動作するよう制御する責任
      - 単一責任の原則: クラスが担う責任は、たったひとつに限定すべきとする設計原則
   4. 単一責任の原則違反で生まれる悪魔
      - 単一責任の原則の未履行が過保護なクラスと未熟なクラスを生み、さらに重複コードを生む。
   5. 責任が単一になるようクラスを設計する
      - 例: 商品の定価クラスを親とし、それを通常割引価格とかき割引価格がそれぞれ別に継承する。
      - 関心事それぞれが分離、独立している構造を疎結合という
   6. DRY の原則の誤用
      - DRY の原則: 全ての知識はシステム内において、単一、かつ明確な、そして信頼できる表現になっていなければならない。
      - 同じようなロジック、にているロジックであっても、概念が違えば DRY にすべきではない。
      - DRY にしすぎると密結合になり、単一責任原則を遵守できなくなる。
2. 密結合の各種事例と対処方法
   1. 継承に絡む密結合
      - 本書のスタンス: 継承はよっぽど注意して扱わないと危険、継承は推奨しない。
      - スーパークラス依存: サブクラスはスーパークラスの変更の影響をもろに受けるので、常に気にしなければならない。
      - 継承より委譲
        - 委譲とは、コンポジション構造にすること
        - 委譲: スーパークラスを継承するのではなく、private なインスタンス変数として持ち、呼び出せるようにすること
      - 関連知識が基底クラスと継承クラスに分散してしまう
   2. インスタンス変数ごとにクラス分割可能なロジック
      - インスタンス変数とそれを用いたメソッドのセットが他のセットと依存関係にないのなら、クラスを分離するべき
      - 影響スケッチ: インスタンス変数やメソッドがそれぞれ何に関係付けられているのか把握するための図
      - 影響スケッチ描画ツール: Jig
   3. なんでも public で密結合
      - public: すべてのクラスからアクセス可能
      - protected: 同じクラス、または継承クラスからアクセス可能
      - なし: 同じパッケージからのみアクセス可能
      - private: 同じクラスからのみアクセス可能
   4. privare メソッドだらけ
   5. 高凝集の誤解からくる密結合
      - 高凝集を意図して強く関係していそうなロジックを一箇所にまとめあげようとしたものの、結果として見つけつ行に陥っているケースは非常に多く見られる。誰もが極めて陥りやすい罠。
      - 疎結合高凝集を意識しなければならない。
      - 疎結合高凝集: モジュール（クラス）の中は密接に関連した機能をまとめ（高凝集）、モジュール間の依存関係は最小限に抑える（疎結合）設計原則
   6. スマート UI
      - スマート UI: 表示関連のクラスの中に、表示遺体の責務のロジックが実装されている構造
      - スマート UI は表示責務と表示以外の計算等の責務が密結合になっているせいで、変更が難しくなる。
      - 責務毎にグラスを分割すべき。
   7. 巨大データクラス
      - 巨大データクラス: 大量のインスタンス変数を保持するクラス
      - 巨大データクラスの持つデータがグローバル変数の性質を帯びてしまうことがあるので注意。
   8. トランザクションスクリプトパターン
      - トランザクションスクリプトパターン: メソッド内に一連の処理手順がダラダラと長く書き連ねられている構造
   9. 神クラス
      - 神クラス: 1 クラス内に何千何万行ものロジックを持ち、あらゆる責務のロジックが乱雑に絡み合うようにかき殴られているようなクラス
      - 大変扱いにくいものになってしまう
   10. 密結合クラスの対処法
   - 巨大データクラスもトランザクションスクリプトパターンも神クラスも、密結合なクラスの対処方法はどれも同じ。
   - オブジェクト指向設計と単一責任の原則に基づき、丁寧に設計すること。

# 第 9 章 設計の健全性をそこなうさまざまな悪魔たち

1. デッドコード
   - デッドコード: どんな条件であっても決して実行されないコード
   - 到達不能コードともいう
   - 発見次第すぐに削除する
2. YAGUNI 原則
   - You aren't going to need it. -- 必要ないでしょう。
   - YAGUNI 原則: 実際に必要になっとときに実装せよ。先回りして必要のないロジックを実装しない。
3. マジックナンバー
   - マジックナンバー: ロジックないに直接書き込まれている意味不明な数値
   - マジックナンバーにならないよう、定数として定義する。
4. 文字列型執着
   - 文字列型執着: String title = "タイトル, 255, 250, 240, 64"のようなもの
   - 扱い方が複雑になるので避ける
5. グローバル変数
   - グローバル変数: どこからでもアクセス可能な変数。public static などで宣言される。
   1. 影響範囲を最小化するよう設計すること
      - 呼び出し箇所が少なく、局所化されているほど、ロジックの理解が容易になる。
      - 無関係なロジックからはアクセスできないように設計する
6. null 問題
   - null を使いがちだが、
   - 本来 null とは、「参照が何も指していない状態」または「参照の欠如」を表す特別な値であり、「空」や「未設定」とは異なる概念。
   1. null を返さない、渡さない
      - null チェックだらけにならないようにするためにも、そもそも null を取り扱わない設計にすることが大切
   2. null 安全
      - null 安全: null が原因のエラーを発生させない仕組み
      - null 非許容型: null を許容しない型
7. 例外の握りつぶし
   - 例外の握りつぶし: 例外が発生しても何も対処せず、エラーを無視してしまうこと。特に空の catch ブロックを作ることで、エラーの発生を隠蔽してしまう行為
   1. 原因分析困難に陥り開発者を疲弊させる
   2. 問題検出時にけたたましく叫ばせる
8. 設計秩序を破壊するメタプログラミング
   - メタプログラミング: プログラム実行時にそのプログラム構造自体を制御するプログラミング
   1. リフレクションによるクラス構造および値の変更
      - リフレクションを使うと final で不変にした変数を可変にすることができてしまう
   2. 型の強みを活かせなくなるハードコード
      - リフレクションを使うと、クラス名を Stringto として渡すことでクラスを生成することができる。
      - しかし、クラス名を変更してしまえば、その処理は機能しなくなる。
      - 名前によるクラスの生成は、IDE がクラスの生成として見つけることもできない。
   3. デメリットを理解しようとを限定すること
      - メタプログラミングは黒魔術
9. 技術駆動パッケージング
   - 技術駆動パッケージング: 設計パターンなど、構造的ににているもの同志でフォルダ分け、パッケージ分けなどをすること
   - ビジネス概念として強く関係試合もの同志が一緒になるようにフォルダ分けをしなければならない
10. サンプルコードのコピペ

- サンプルコードには保守性や変更用意性まで考えて書かれていない

11. 銀の弾丸

- 現実のプロジェクトで発生する問題は特定の手法だけで解決可能なほど単純でない
- 銀の弾丸や特攻薬のようなものは求めないようにする

# 第 10 章 名前設計 -- あるべき構造を見破る名前 --

0. 導入

- 目的駆動名前設計: コードの名前（クラス名、メソッド名、変数名）を、その目的や意図が明確に伝わるように設計すること

1. 悪魔を呼び寄せる名前
   1. 関心の分離
      - 関心の分離: 関心事それぞれのクラスへの分割が必要
   2. 関心事にふさわしい命名
      - 商品ではなく、予約品、注文品、在庫品、発送品 など、関心事にふさわしい命名をする
      - クラス毎の影響範囲が低減し、開発効率が上がる
   3. 大雑把で意味が不明瞭な名前
      - 開発初期に決めた名前は大雑把であることがおおい
      - 目的不明オブジェクト: 名前が大雑把で目的がわからないオブジェクト。
2. 名前を設計する -- 目的駆動名前設計
   - プログラミングにおける名前の役割は、可読性を高めることだけではない
   - 目的駆動名前設計のポイント
     - 可能な限り具体的で、意味範囲が狭い、特化した名前を選ぶ
     - 存在ベースではなく、目的ベースで名前を考える
     - どんな関心事があるか分析する
     - 声に出して話してみる
     - 利用規約を読んでみる
     - 違う名前に置き換えられないか検討する
     - 疎結合高凝集になっているか点検する
   1. 可能な限り具体的で、意味範囲が狭い、目的に特化した名前を選ぶ
      　 - 極めて意味範囲の狭い名前をクラスに付与し、ビジネス目的に特化することで得られる効果 - 名前とは無関係なロジックを排除しやすくなる - クラスが小さくなる - 関係するクラスの個数が小さくなる。結合度が低減する。 - 関係クラスの個数が少ないので、使用変更時に考慮を要する影響範囲が小さく済む。 - 目的に特化した名前なので、どこを変更すれば良いかすぐ探し出せる。 - 開発生産性が向上する。
   2. 存在ベースではなく、目的ベースで名前を考える。
      - 目的ベースで考えた命名の例
        - 住所: 発送元、発送先、勤務先、本籍地
        - ユーザー名: アカウント名、表示名、本名、法人名
   3. どんなビジネス目的があるのか分析する
   4. 声に出して話してみる
      - ラバーダッキング: 問題に直面したとき、そのことを誰かに話すことによって自ら原因に気づき、自己解決する手法
   5. 利用規約を読んでみる
      - サービスの利用規約には厳密な言葉が使われている。
      - 利用規約からクラス名のヒントが得られることがある。
   6. 違う名前に置き換えられないか検討する
      - 「顧客」でも広い。「宿泊客」と「支払い者」に分けるなど。
   7. 疎結合高凝集になっているか点検する
      - 低凝集や密結合になっているなら、もっと狭い意味の、特化した名前を探してみる。
3. 設計時の注意すべきリスク
   1. 名前無頓着になるな
      - チーム開発においては、命名が重要であり、名前とロジックが対応する前提であること、名前がプログラム構造を大きく左右することをチームで約束すること
   2. 使用変更時の「意味範囲の変化」に警戒
      - 名前と中身は連動している。
      - 一方の仕様が変わるなら、もう一方についても検討するべき
   3. 会話には登場するのにコード上に登場しない名前に注意
      - 会話に登場する重要な概念が、ソースコード上で名前も付けられず、雑多なロジックの中に埋没していることが本当に頻繁に見受けらる。
      - その概念をソースコード上から見つけるのが大変になってしまう
   4. 形容詞で区別が必要なときはクラス化のチャンス
      - 違いの見分けが難しいコードを、口頭でひたすら形容詞をつけて同僚に説明する状況がある。
      - 「元々の〜」「補正された〜」などの形容詞を用いて、説明する必要があるのなら、それはクラス化する必要がある
      - 要注意感イン、新品価格、中古価格、シニア料金用、平日のシニア料金用 など
4. 意図がわからない名前
   - 命名で陥りがちなさまざまな悪しきケース
   1. 技術駆動命名
      - 技術駆動命名: プログラミング用語やコンピューター用語由来の命名
      - MemotyStateManager, changeIntValue01 など
   2. ロジック構造をなぞった名前
      - isMemberHpMoreThanZeroAndIsMenberCanAct のようなもの
      - 意図、目的がわかるよう命名しよう
   3. 驚き最小の原則
      - 驚き最小の原則: 使う側が想像した通りに利用できるよう、ロジックと名前を対応付ける設計が大事
5. 構造を大きく歪ませてしまう名前
6. データクラスに陥る名前
   - ~Data, ~Ingo のような命名はデータクラスを生んでしまう。避けよう。
   - Data Transfer Object (DTO) : 「データを運ぶだけの単純なオブジェクト」は認められる。
7. クラスが巨大化する名前
   - ~Manager, ~Service, ~Controller のような命名は、クラスが巨大化する原因になる。
   - より厳密な命名をする
8. 状況によって意味や扱いが異なる名前
   - アカウント: 金融業界では「銀行口座」、コンピューターセキュリティでは「ログイン権限」
   - 状況により意味合いが異なる
   - コンテキスト（状況）が違う場合についてはクラスを分けよう。
   - Car でも配送局面と販売局面でコンテキストが全く違うのでクラスを分ける。
9. 連番命名
   - 連番命名: クラスやメソッドに番号をつけて命名すること
   - 連番命名はトランザクションスクリプトパターンに容易に陥らせてしまう
   - トランザクションスクリプトパターン: メソッド内に一連の処理手順がダラダラと長く書き連ねられている構造
10. 名前的に居場所が不自然なメソッド
    1. 「動詞 + 目的後」のメソッド名に注意
       - addItemToParty のような「動詞 + 目的後」の命名は不適切なクラスへの実装だからこそ起こりやすい。
    2. 可能な限り同志１語で済む名前にする
       - 「動詞 + 目的後」のメソッドは、目的後の概念を表現するクラスをつくり、そこに動詞１語のメソッドとして実装する。
       - addItemToParty のようなメソッドは、PartyItenms クラスに add()として実装する。
    3. 不適切な居場所の boolean メソッド
       - boolean 型を返すメソッドは責務外のクラスに実装されがち
       - クラス名 is 状態. にして適切な文章になれば OK
       - Member is in confusion. → 　 Menber クラスに isConfusion()メソッドを実装する
11. 名前の省略
    - 名前の省略には注意が必要
    1. 意図がわからなくなる省略
       - 長い名前が嫌なため、省略した名前が書かれてしまう → 意図がわからなくなる
    2. 基本的に名前は省略しないこと
       - エディタの保管機能があるから大丈夫。省略せずに書こう。
    3. そのほか省略をどう判断するか
       - 可能な限り省略せ雨ｚに意図を伝える命名が望ましい

# 第 11 章 コメント -- 保守と変更の正確性を高める書き方 --

0. 導入
   - 理解を促し、保守や変更の正確性を高めるコメントとは
1. 退化コメント
   - 退化コメント: 情報が古くなり実装を正しく説明しなくなったコメント
   1. コメントは書き手の意思の劣化コピーにすぎないことを理解すること
   2. ロジックの挙動をなぞるだけのコメントは退化しやすい
      - ロジックの挙動をなぞるだけのコメントは理解にさほど貢献しない上に、逆に偽情報が紛れ込んで害をなす可能性があり、役立たない。
2. コメントで命名をごまかす
   - ダメなメソッドに対してコメントで補足説明が必要になったときには、メソッド名のブラッシュアップを考えよう。
3. 意図や仕様変更時の注意点を読み手に伝えること
   - コードは保守と使用変更時に読まれる
   - コード保守の際、読み手が気にすること「このロジックはどういう意図で動いているのか」
   - 仕様変国の際、読み手が気にすること「何に注意すれば安全に変更できるか」
4. コメントのルール まとめ
   - コメントのルールまとめ
     | ルール | 理由 |
     |--------|------|
     | ロジック変更時、同時に必ずコメントも変更すること。 | コメントを変更しないと、ロジックと乖離した「退化コメント」が生じ、読み手が混乱するため。 |
     | ロジックの内容をなぞるだけのコメントをしないこと。 | あまり可読性に貢献しない上、コメントのメンテナンスが大変になるため。退化コメントも発生しやすい。 |
     | 可読性の悪いロジックを補足説明するようなコメントをしないこと。代わりにロジックの可読性を高めること。 | コメントのメンテナンスが大変になるため。退化コメントも発生しやすい。 |
     | ロジックの意図や仕様変更時の注意点をコメントすること。 | 保守や仕様変更時の助けになる。 |
5. ドキュメントコメント
   - 積極的に使おう！コードの保守に特に役立つ。
     | Javadoc タグ | 用途 |
     |------------|------|
     | @param | 引数の説明 |
     | @return | 戻り値の説明 |
     | @throws | 例外の説明 |
     | @deprecated | 非推奨の説明 |
     | @see | 関連するクラスやメソッドの説明 |
     | @since | 導入されたバージョン |
     | @version | バージョン番号 |

# 第 12 章 メソッド（関数） -- 良きクラスには良きメソッドあり --

1. 必ず自身のクラスのインスタンス変数を使うこと
   - 他のクラスのインスタンス変数を変更するメソッド構造にしてはだめ。低凝集に陥る。
2. 不変をベースに予期せぬ動作を防ぐ関数にすること
   - 可変なインスタンス変数などを変更するメソッドは意図せず別の箇所に影響を及ぼし、予測しない動作が生じる場合がある。
3. 訪ねるな、命じろ
   - 「よそのクラスを気にしたりいじったりするメソッド構造」は低凝集構造
   - シンプルな setter/getter でインスタンス変数を返し、呼び出し側で複雑な処理をさせるのではなく
   - 呼び出されるメソッド側で複雑な処理をしたうえで、結果を返すようにする。
4. コマンド・クエリ分離
   - int gainAndGetPoint() のような変更と取得を同時に行うメソッドは混乱をもたらしやすい
   - コマンド・クエリ分離: メソッドをコマンド（変更）とクエリ（取得）に分ける
5. 引数
   １。引数は不変にすること
   - 引数には final を付与する
   - 引数を変更したい場合は、不変なローカル変数を容易し、そのローカル変数に変更値を代入する
   2. フラグ引数は使わない
      - ストラテジパターンなど別の機能切り替え手法を使う
   3. null を渡さない
      - null を前提としたロジックを実装しない
   4. 出力引数は渡さない
      - 入力値である引数を出力に用いない
   5. 引数は可能な限り少なく
6. 戻り値
   1. 「型」を使って戻り値の意図を表明すること
      - int add() と Price add() とでは戻り値の明瞭性が違う。後者がわかりやすい。
   2. null を返さない
   3. エラーは戻り値で返さない、例外をスローすること
      - エラーを特殊な値で知らせるのではない
      - エラーは例外をスローして知らせる

# 第 13 章 モデリング -- クラス設計の土台 --

- モデル: 動作原理やしくみを簡単に理解・説明するために、物事の解く量や関係性を図式化したもの
- モデリング: モデルを作ること

1. 邪悪な構造に陥りがちな User クラス
   - 例えば、１つのデータクラスを２つの~Manager クラスで管理するようなケースはだめ
2. モデリングの考え方とあるべき構造
   1. システムとは何か
      - システム: 目的達成のための手段
   2. システム構造とモデリング
      - モデルとは特定の目的達成のために最低限考慮が必要な要素を備えたもの
   3. ソフトウェア設計におけるモデリング
      - モデルを目的別に分けて書くようにすると、クラスの分かれ目に気づくことができる
3. よくないモデルの問題点と解決方法
   - 複数の目的のために無理やり利用されているような構造はだめ
   - 一貫性がないといえる
   1. User とシステムの関係
      - よく考えると、User はシステムの外にいる
   2. 仮想世界を表現する情報システム
      - 情報システムとは、現実世界の概念のみをコンピューターの世界へ東映した仮想現実である
   3. 目的別にモデリングする
      - モデルは「特定の目的達成のために最低限考慮が必要なようをを備えたもの」
      - 目的に応じて形態が変わってくる
      - 現実世界での物理的な存在と、情報システム上のモデルが 1:1 になるとは限らず、1:多の関係になるケースがあることが大きな解く量
      - User が個人アカウント、法人アカウント、プロフィール、会社概要、職務経歴 と分かれる
      - そもそも User という名前自体の意味が広い
   4. モデルはモノではなく目的達成手段
      - PersonalAccout は個人認証手段、Profile は特徴表現手段
      - 目的駆動で名前設計することが、適切に目的達成するモデルを設計することにつながっている
   5. 単一責任とは単一目的
      - 単一責任の原則とは、単一目的の原則である
      - クラスが果たす目的は、たった一つに限定すべき
      - 特定の目的に特化して設計することで、変更につよい高品質な構造になる
      - システムはなんらかの目的を達成するためにつくられるのであり、責務よりも目的が先にくる
   6. モデルの見直し方
      - モデルにいびつさ、不自然さ、一貫性のなさを感じた場合には以下を検討する
        - そのモデルが達成しようとしている目的を全て洗い出す
        - 目的それぞれ特化したモデリングをし直す
        - 目的駆動名前設計にもとづき、モデルに命名する
        - モデルに目的外の要素が入りこんでいる場合、さらに見直す
