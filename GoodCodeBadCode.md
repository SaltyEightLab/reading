# はじめに

- こんなことはありませんか？
  - どこかのコードを変更すると、別の場所でバグが発生した。
  - 変更の影響がありそうな箇所を。あちこち探し回らなければならなくなった。
  - コードを読んでいるだけで日が暮れてしまった。
  - 簡単んだと思っていた仕様変更やバグ修正に何日も費やしてしまった。
  - 開発力を貶め、ソフトウェアの成長を阻害する、設計や実装状の問題、つまり「悪魔」を近くし、退治できるようにするための技術書。

# 第１章 悪しき構造の弊害を知覚する。

0. 導入
   - 設計を蔑ろにすることで発生する弊害
     - コードを読み解くのに時間がかかる
     - バグを埋め込みやすくなる
     - 悪しき構造がさらに悪しき構造を誘発する
1. 意味不明な命名
   - 技術駆動命名や連番命名は意図が全く読み取れない、悪しき手法
2. 理解を困難にする条件分岐のネスト
   - 深すぎるネストは理解困難
3. 様々な悪魔を招きやすいデータクラス
   - データの保持だけを目的としたクラスをデータクラスという
   - データクラスとそのデータを操作するクラスが別になっている場合がある
   - そのようなバラバラの状態を低凝集であるという
   - 低業集であると弊害がいろいろとある
     - 重複コード
     - 修正漏れ
     - 可読性低下
     - 未初期化状態・生焼けオブジェクト
     - 不整地の混入
4. 悪魔退治の基本
   - 悪しき構造の弊害とオブジェクト指向設計をしることで弊害を退治することができる

# 第２章 設計の初歩

0. 導入
   - 変数やメソッドなどの小さな単位の設計について扱う
1. 省略せずに意図が伝わる名前を設計する
2. 変数を使いまわさない、目的ごとの変数を用意する
   - 再代入は読み手の混乱を招くので避ける。
3. ベタ書きせず、意味のあるまとまりでメソッド化
4. 関係し合うデータとロジックをクラスにまとめる

# 第３章 クラス設計 -- 全てにつながるい設計の基盤 --

0. 導入
   - クラスベースのオブジェクト指向設計の基本について扱う
1. クラス単体で正常に動作するよう設計する
   - まどろっこしい初期設定をせずとも初めから使える設計にする
   - 正しく操作できるメソッドのみを外部に提供する
   1. 悪魔に負けない、頑強なクラスの構成要素
   - 良いクラスの構成要素
     - インスタンス変数
     - インスタンス変数を不正状態から防御し、正常に操作するメソッド
   2. すべてのクラスに備わる事故防衛責務
   - 単体で安全に利用できる自己防衛責務を全てのクラスが備えるという考えかたがソフトウェア品質を考える上で重要
2. 成熟したクラスへ成長させる設計術
   1. コンストラクタで確実に正常値を設計する
      - 初期化時以外でインスタンス変数に値を代入しないと使えないクラスは生焼けオブジェクト
      - 生焼けオブジェクトを防ぐには、「クラスのインスタンスを生成する時点で、インスタンス変数に正常値が確実に設定されている状態」にする
      - コンストラクタに不整地を渡せないように、バリデーションチェックも忘れずに
      - 処理の対象外となる条件を先頭で定義する方法をガード節という
   2. 計算ロジックをデータ保持側に寄せる
   3. 不変で思わぬ動作を防ぐ
      - 新スタンス変数の上書きは、理解を難しくする。
      - インスタンス変数を不変（イミュータブル）にする
   4. 変更したい場合は新しいインスタンスを作成する
      - インスタンス変数を変更したい場合は新しいインスタンスを生成するようにする
      - add() return new Money(addedAmount) のようなメソッドを用意しておく
   5. メソッド引数やローカル変数にも final を付け不変にする
      - void doSomething(final int amount) のように引数もイミュータブルにする
   6. 「値の渡し間違い」を型で防止する
      - 数値だからといって、考えなしに全て int 型では、チケットの枚数と間違えてチケットの金額を渡してしまうなどのミスが発生する。
      - 金額なら Money 型、枚数なら TicketCount 型などといった具合に型を使って値の渡し間違いを防ぐ
   7. 現実の営みにはないメソッドを追加しないこと
      - 金額同士の乗算のような、現実にないメソッドはバグの原因になる
3. 悪魔退治の効果を検証する

   - クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくりと言っても過言ではない
   - 密接に関係し合うロジックが一箇所にぎゅっと集まっている構造を高凝集と呼ぶ
   - データとそのデータを操作するロジックを一つのクラスにまとめ、必要なメソッドのみを外部へ公開することをカプセル化という

4. プログラム構造の問題解決に役立つ設計パターン
   - プログラム構造を改善する設計手法を設計パターン（デザインパターン）という
   - 設計パターンの例
     - 完全コンストラク: 不正状態から防護する
     - 値オブジェクト: 特定の値に関するロジックを高凝集にする
     - ストラテジ: 条件分岐を削減し、ロジックを単純化する
     - ポリシー: 条件分岐を単純化したり、カスタマイズできるようにする
     - ファーストクラスコレクション: 値オブジェクトの亜種で、コレクションに関するロジックを高凝集にする
     - スプラウトクラス: 既存のロジックを変更せずに安全に新機能を追加する
   1. 完全コンストラクタ
      - 不正状態から防護するための設計パターン
      - インスタンス変数を全て初期化するコンストラクタ
      - コンストラクタ内でガード節を使って不正状態を防ぐ
   2. 値オブジェクト
      - 値をクラスとして表現する設計パターン
      - 値にもいろいろある。それぞれのロジックを高凝集にする効果がある
      - 値オブジェクトと完全コンストラクタはオブジェクト指向設計の基本形を体現している構造の一つ

# 第４章 不変の活用 -- 安定動作を構築する --

0. 導入
   - 変更可能なことを可変（ミュータブル）、不可能なことを不変（イミュータブル）という
1. 再代入
   - 変数に再度値を代入することを再代入、または、破壊的代入という
   - 再代入はそのタイミングを追うのが難しくなる
   - 別の変数を用意するべき
   1. 不変にして再代入を防ぐ
      - final を付与する
   2. 引数も不変にする
      - 引数にも void doSomething(final int amount) のように fainal を付与する
2. 可変がもたらす意図せぬ影響
   1. 可変インスタンスの使い回し
      - 意図せずに変更してしまうことがある
   2. 関数による可変インスタンスの操作
   3. 副作用のデメリット
      - 関数の主作用: 関数が引数を受け取り、値を返すこと
      - 関数の副作用: 主作用以外に状態変更すること
      - 副作用の例
        - インスタンス変数の変更
        - グローバル変数の変更
        - 引数の変更
        - ファイルの読み書きなどの I/O 操作
      - 副作用が予期せぬタイミングで働いてしまう場合がある
   4. 関数の影響範囲を限定する
      - 副作用を抑えるため、関数が影響を受ける・与える範囲を限定するのが確実
      - 関数を次のように設計する
        - データ、つまり状態を引数で受け取る
        - 状態を変更しない
        - 値は関数の戻り値として返す
      - オブジェクト指向では、副作用のない関数を厳密に作り込むのではなく、クラスのスコープ内で影響を閉じ込めるスタイルが一般的
   5. 不変にして予期せぬ動作を防ぐ
3. 可変と不変の取り扱い方針
   - 可変と不変をどのように扱っていけばいいのか？
   1. デフォルトは不変に
      - 不変にすることによるメリット
        - 変数の意味が変化しなくなるので、混乱が抑えられる
        - 挙動が安定し、結果を予測しやすくなる
        - コードの影響範囲が限定的になり、保守が用意になる
      - 間違った使い方ができない構造をフールプルーフという
   2. どんなとき可変にしてよいか
      - インスタンスを生む処理がパフォーマンスの面で問題なら可変もありえる
      - スコープが局所的な場合も可変がありえる
   3. 正しく状態変更するメソッドを設計する
      - 可変にする場合は、正しく状態変更できるつくりにする
      - 状態変更メソッドをミューテーターという
   4. コード外とのやりとりは局所化する
      - どれだけ不変を意識しても、I/O 操作や DB 操作など、コード外の状態に依存する場合はある
      - なので、あまり考えずに外の状態に依存するコードを書くと、挙動の予測が困難になる
      - 影響を最小限にするための局所化の設計手法としてリポジトリパターンが人気
      - リポジトリパターン: データベースの永続化処理をカプセル化する設計パターン

# 第 5 章 低凝集 -- バラバラになったモノたち --

0.  導入
    - 高凝集は変更に強い、望ましい設計
    - 低凝集は壊れやすく変更が困難
1.  static メソッドの誤用
    1. static メソッドはインスタンス変数を使えない
       - static メソッドはインスタンス変数を扱えない時点でデータとデータを扱うロジックが乖離する
    2. インスタンス変数を使う構造につくり変える
    3. インスタンスメソッドのフリした static メソッドに注意
       - static キーワードがついていないだけで、static メソッドと同じ問題をかけているインスタンスメソッドもよくある
       - 試しに、メソッドに static を付与して、エラーが派生しなければそれは実質 static メソッドだ
    4. どうして static メソッドが使われてしまうのか
       - 手続き型言語の名残り
    5. どういうとき static メソッドを使えばいいのか
       - ファクトリメソッドとして static メソッドを用いるのがよい
2.  初期化ロジックの分散
    - 本当にコンストラクタを公開してよいのか吟味する
    - コンストラクタを公開すると、様々な用途であちこちで使われてしまう
    - 用途を限定したいならば、コンストラクタを private にして、static な目的別のファクトリメソッドを用意する
    1. private コンストラクタ + ファクトリメソッドで目的別初期化
    2. 生成ロジックが増えすぎたらファクトリクラスを検討すること
       - 複数の生成パターンがあり、使い分けが必要（通常ユーザー、プレミアムユーザーなど）
3.  共通処理クラス（Common・Util）

    - 同じような処理が多数描かれそうなとき、再利用できるよう共通処理を実装した共通クラスがつくられることがある。
    - このとき、共通処理用のメソッドは static メソッドとして実装されがち
    - Common.calcAmoutIncludingTax(amount) のようなもの
    - これもまた低凝集である

    1. さまざまなロジックが雑多に置かれがち
       - なんの関連性もないその他のロジックの置き場になってしまう場合がある
    2. オブジェクト指向設計の基本に立ち返ろう
       - 共通処理クラスを安易に作らないようにしよう
    3. 横断的関心事
       - 横断的関心事は共通処理クラスにまとめ上げていい
       - 横断的関心事: 様々なユースケースに広く横断する事柄
         - ログ出力
         - エラー検出
         - デバッグ
         - 例外処理
         - キャッシュ
         - 同期処理
         - 分散処理
    4. 結果を返すために引数を使わないこと
       - 引数はあくまで入力値
       - メソッドの中で引数として受け取ったものを再代入したり、出力に用いたりしない
       - 低凝集の原因になる
    5. 多すぎる引数

       - 引数が多すぎると低凝集になりがち
       - 引数が多すぎると、引数の渡しミスが発生しやすい

       1. プリミティブ型執着

          - プリミティブ型を濫用したコードをプリミティブ型執着という
          - 例えば、プリミティブ型を使用すると同様のバリデーションが重複してしまう price < 0 など
          - 値とそれを操作するためのメソッドが存在する以上、セットにしておくのが適切
          - 割引料金、定価、割引率なども、それぞれ一つずつクラス化する

       2. 意味のある単位ごとにクラス化する

          - 引数が多すぎる事態に陥らないためには、概念的に意味のあるクラスをつくることが肝要
          - 引数が多い場合は、データを引数として扱うのではなく、その値をインスタンス変数としてもつクラスにできないか検討するとよい

    6. メソッドチェイン

       - 長すぎるメソッドチェインに値を代入するようなケースも低凝集に陥りやすい例
       - party.members[memberId].equipments.armor = newArmor; のようなコード
       - デメテルの法則: 「最小知識の原則」とも呼ばれる、「オブジェクトは、直接の友人とだけ会話すべき」という考え方

       1. 尋ねるな、命じろ

       - Don't ask, tell(訪ねるな、命じろ): オブジェクトの内部状態を外から取得して判断するのではなく、オブジェクトに直接処理を命じるべき

       - 悪い例（外部で計算）

       ```typescript
       // 外部で計算（尋ねて判断）
       const product = new Product(1000, 0.2);
       const price = product.getPrice();
       const rate = product.getDiscountRate();
       const finalPrice = price * (1 - rate); // 外部で計算ロジックを実装
       ```

       - 良い例（オブジェクトに命じる）

       ```typescript
       // 商品に計算を命じるだけ
       const product = new Product(1000, 0.2);
       const finalPrice = product.calculateDiscountedPrice();
       ```

# 第 6 章 条件分岐 -- 迷宮かした分岐処理を解きほぐす技法 --

1. 条件分岐のネストによる可読性低下
   1. 早期 return でネスト解消
      - 早期 return: 条件を満たしていない場合に、直ちに return すること
      - 早期 return に変更するには、元の条件を反転させる
      - 早期 return はガード節の考え方が元になっている
   2. 見通しを悪くする else 句も早期 return で解決
      - else 句も、見通しを悪くする要因の一つ
2. switch 文の重複

   1. 即座に switch 文を書いてしまう
   2. 同じ条件式の switch 文が複数かかれていく
   3. 使用変更時の修正漏れ(case 文追加漏れ)
   4. 爆発的に増殖する switch 文の重複

      - 大量に分岐していくものを switch 文で処理しようとするとミスが発生する

   5. 条件分岐を一箇所にまとめる
      - switch 文の重複コードを解消するには、単一責任の原則の考え方が重要
   6. よりスマートに switch 文重複を解消する interface
      - interface は異なる型を同じ型として利用できるようにするもの
   7. interfafce を switch 重複文に応用（ストラテジパターン）
      - interface Shape に area()メソッドを定義して、Circle や Rectangle でもこれを継承することにより、それぞれの area()メソッドを定義することができる
      - Map<final MagicType, final Magic> の中から、MagicType に対応する Magic を取得することで魔法を切り替える手法もいい考え
      - ストラテジパターン: interface を用いて処理を一成に切り替える設計
      - interface を implements した場合、変数やメソッドのオーバーライドを忘れることがなくなる

3. 条件分岐の重複とネスト
   - interface は多重ネストの解消にも役立つ
   1. ポリシーパターンで条件を集約する
      - ポリシーパターン: 「同じような処理だけど、状況によって少しずつ異なる振る舞いが必要な場合に、その振る舞いを別々のクラスとして実装し、実行時に切り替えられるようにするデザインパターン」
      - 例えば：
        - 会員ランクによって異なる割引率の計算
        - ユーザーの状態によって異なる通知方法
        - 支払い方法による異なる決済処理
      - など、「同じような処理だけど、条件によって少し違う」というケースで使用します。
4. 型チェックで分岐しないこと
